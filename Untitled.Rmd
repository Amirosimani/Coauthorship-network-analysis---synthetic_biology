---
title: "Collobration network analysis"
author: "Amir Imani"
date: "1 September 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Nowadays in every field, people collobrate with each other.There are alot of intersing collobation network analysis projects out there like rappers (http://arxiv.org/pdf/physics/0511215.pdf),co-stardom analysis (https://en.wikipedia.org/wiki/Co-stardom_network), and scientific collobarion. The colloration network is formed as indvidulas with different skills/knowledge/professions interact with each other to facilitate fulfillment of  tasks to a mutally shared goal. Collboration provides opportunity to all the parties involved to discover new knowledge/experinece/skills and consequenty combine them to address a complex challenge.

Since for I already have a few thousands journal articles on ethics of Synthetic Biology written from 2004 to 2014, I decided to write this walkthrough on how to do the co-authorship analysis. Scientific collaborative networks are a hallmark of contemporary academic research. Scientists are no longer independent players, but members of scientific cooperation networks looking for solutions to social, political, economic and technological problems, which, usually, require multidisciplinary approaches (http://goo.gl/GtwV02). Scientific collaboration can also help broaden the scope of a research project and foster innovation as it provides access to different disciplines. 

Co-authorship analysis enables us to understand and disvocer scientific collaboration patterns. It can be used to asses the extend of collaboration within a research area, evaluate the relation between authors and their significance in a given network, contirbution of insitutions or larger organisaitons, formation of research groups, and so on. 

Regardless of what kind of collaboration network you want to analysis, you'll need an edge list where individulas are unique nodes with edges connecting them to each other if they have colloborated. In scientific co-authorship networks, nodes represent authors, organizations or countries, which are connected when they share the authorship of a paper.

***
## ANALYSIS

### importing the file

For this post, I picked a random sample of 100 articles and scraped the authors (which I will write about in another post) to start with. It looks like the table below. You can find all the files and codes on my ***github repo***.

First Author |             |            |            |            |             |
------------ | ----------- | ---------- | -----------| -----------| ------------| ----------
Adam Arkin   |	Pamela A. Silver |	George Chruch							
Ahmad S. Khalil|	Agomoni Ganguli-Mitra							
Ali Nouri |	Alan Irwin	|							
Amelie Cserer	| Alexander van Oudenaarden							
Anna Deplazes |	Alexandra Seiringer								
Baker David |	Anna Labno| Collins Jim	| Endy Drew|	Jacobson  Joseph |	Keasling Jay |	Modrich Paul|	Smolke Christina	| Weiss Ron	
Barry Canton |	Antoine Danchin	| Drew Endy							
Brian J Yeh |	Arthur Caplan								
Brianna Pearson	| Barbara A. Fechta	| Kyri Bye-Nagel|	Scott Tonid	| Laurie J Heyer |	Malcolm Campbell				
C. Verharen |	C. Prowse|	G. Middendorf	|M. Castro-Sitiriche|	G. Kadoda 					
Christian L Barrett |	Chris J. Paddonb|	Hyun Uk Kim	| Bernhard Ã‹ Palsson|	Sang Yup Lee					
Christina D. Smolke |	Christopher F Chyba								

```{r file, eval=FALSE}
source_file = read.csv(file.choose(), sep = ";", header = F)
```

### Converting a table to an edgle list

There are many approaches to turn a table to an edge-list. I defined a function using **reshape** library.
The idea is to melt the table starting from the first column, then drop it and move to the next column.

```{r Matrix2Edge, eval=FALSE}

library(reshape)

Matrix2Edge <- function(x){
  final <- data.frame("a"=character(),"b"=character()) #an empty dataframe to add the edge list to
  
  for (i in 1:(ncol(x)-1)){
    id = paste("V", i, sep="")
    edge_list <- melt(x, id = (id))
    x[id] <- NULL
    keeps <- c(id, "value")
    edge_list <- edge_list[keeps]
    colnames(edge_list) <- colnames(final)
    final <- rbind(final,edge_list)
  }
  final <- final[!(final$b=="" | final$b==" "),]
  return(final)
}
```

Then Using the function with the > source_file as the input 

```{r edge_list, eval=FALSE}
edge_list <- Matrix2Edge(source_file)
```

The result is a two-colmumn table where each row is an edge indiciating every two authors who collobareted in a paper. 
* One important remark about scientific co-authorship is that not all authors have contributed the same.Based on the field of research, the first author and last author have different level of contirbution comparing to the others. This can be addressed by assgiging a weight factor to those authors.

### ENTITY RESOLUTION

The next step is to make sure that variation in authors names like misspelling, missing the middle name, or the order of first and last name have not created duplicates. This process is called enetity resolution and there
are many approaches to address it in *machine learnin*.

But first, we need to clean up the text. In this case it includes removing numbers, special characters, triming white space, and converting all letters to lowercase, etc to minimize possible discrepencies. To do so, Im using **dplyr** library to convert all letters to lowercase.


```{r cleaning_up, eval=FALSE}
library(dplyr)

edge_list <- as.data.frame(sapply(edge_list, function(x) gsub("[^[:alnum:]]"," ", x))) #removes all non-alphanumerical characters (like punctuations, special characters, etc)

edge_list <- as.data.frame(sapply(edge_list, function(x) trimws(x))) #removes leading and trainling whitespaces

edge_list <- mutate_each(edge_list, funs(tolower))
```

Now entity resolution time (write more about the distance function) ??????????????????????


```{r Ent_Res, eval=FALSE}
library(stringdist)

simmilarity_index <- function(x, y){
  
  sim_index <- 1- stringdist(x, y, method = "lv")/max(nchar(as.character(x)), nchar(as.character(y)))
  return(sim_index)  
}

for (i in 1:nrow(edge_list)){
  for (j in 1:i){
    if (simmilarity_index(edge_list$a[i],edge_list$a[j]) > 0.8){
      edge_list$a[i] <- edge_list$a[j]
    }
  }
}

for (i in 1:nrow(edge_list)){
  for (j in 1:i){
    if (simmilarity_index(edge_list$b[i],edge_list$b[j]) > 0.8){
      edge_list$b[i] <- edge_list$b[j]
    }
  }
}
```

Now that the dataset is ready for network analysis, its good to save it as a new CSV file and use it for the future analysis.

```{r save_file, eval=FALSE}
write.csv(edge_list, file = "edge_list.csv")
```


## Social Network Analysis

Now the edge list is ready, we can start the social network analysis by turing the edge list to a graph data using **igraph** library. Since it is a collaboration network, it should be a non-directod network.

```{r network_graph, eval=FALSE}
library(igraph)

graph=graph.edgelist(as.matrix(edge_list),directed=FALSE)
```

some basic network analysis measures like density and degree of graph can be calcuatled right away.

```{r graph_dens, eval=TRUE}
library(igraph)
graph.density(graph)
```
